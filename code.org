#+TITLE: Coding document for sheep
#+AUTHOR: Thomas Rometsch

* Intro

This is the place where the code for the =sheep= project is written
in a literate programming style.

* Sheep
** Implementation

Here is an outline of the steps =sheep= needs to be able to do.
Generic steps which are the same for avery code are marked by =(g)=.
Steps specific for each code are marked by =(s)=.

1. =(g)= Provide a temporary directory in which to prepare the simulation files.
2. =(s)= Copy all necessary files into the temp directory.
3. =(s)= Set the parameters using the common interface which launches a code specific parser.
4. =(s)= Provide the (re)start and make scripts
5. =(g)= Pack everything into a tar ball.

The programming language is =Python3=. This program probably doesn't support =Python2=!

All specific =(s)= parts need to be implemented for each new code by inheriting the abstract interface.

The changes to the parameter files are first done in memory.
After completing the process of setting the parameters, write the file from memory to the file.

Note that, as a design choice, parameters can only be set if they are
+ already in the config file
+ defined in the setup specific config
which is to avoid typos when setting the parameters automatically.

** Functions to be provided by =sheep=

*** =set_param( name, value )= =(g)=

The function to set parameters should be of the form

+ =name= is the common name of the parameter which is translated to the parameter name in the code via a dictionary.
+ =value= is the value (or possibly multiple values in form of a list) of the parameter

Depending on the parameter, an appropriate code specific function is called.
Therefore, there must be an entry in the file =parameters.txt=

*** =translate_param_name( to_convention, name )= =(g)=

Translate the parameter with =name= to the naming =to_convention=.

E.g. to translate from the generic parameter name =foo= to the code specific name of the code =BarCode= the call would be =translate_param_name( 'BarCode', 'foo')=.

To go the other way around and translate from the parameter with name 'FoO' from the code =BarCode= to the generic parameter name the call looks like =translate_param_name( 'generic', 'FoO')=.

The translation dictionaries need to be provided by the code specific implementation in a file called =parameters.txt=.

*** =enforce_scripts_available()= =(g)=

This functions checks for the scripts
+ =start.py=
+ =restart.py=
+ =make.py=
which are supposed to be copied to the root of the temporary directory.
The function of these scripts is not checked, however.
Its the responsibility of the user to make them work properly.

*** =provide_temp_dir()= =(g)=

This function provides a temporary directory.
The path is written into an object variable.

*** =copy_src()= =(s)=

Copy the source files from a pre-defined directory to the temp directory for editing.
The source files/folders need to be specified in =sources.txt=.

*** =load_param_file( filepath )= =(g), (s)=

Loads the parameter file at =filepath= into memory.
Automatically determine the syntax from the context.

*** =save_param_file( filepath )= =(g), (s)=

Saves the parameter file from the memory to =filepath=.
Automatically determine the syntax from the context.

** Configuration

The configuration of =sheep= is accomplished using simple tab separated plain text files.
Comments in the configuration files can be done using the =#= character.
All text following a =#= character is ignored.

Every code specific sheep is supposed to have its own directory containing the configuration files.
This directory should ideally be inside the directory where the specific setup for the code is stored.

The directory structure of a setup could thus be

#+BEGIN_EXAMPLE
+ source_of_code
+ ini_file_for_code.txt
+ ...
+ sheep
  + sources.txt		# Files and folders to be copied from the parent dir
  + parameters.txt  # parameter names and locations
#+END_EXAMPLE

*** The =parameters.txt= file.

This is the place where the parameters of a specific code are listed.
For every parameter, there must be a line defining the necessary information
+ generic name
+ code specific name
+ file to write the parameter to

The syntax is
#+BEGIN_EXAMPLE
generic_name	code_specific_name	param_file
#+END_EXAMPLE

If the code specific name is the same as the generic name, the second field should contain a minus =-=.

An exmaple:

#+BEGIN_EXAMPLE
DiskMass	-	code_params.txt		# same name
AspectRatio	h_asp	code_params.txt	# different names
#+END_EXAMPLE

Each implementation of the class =Sheep= must define how to read and write
parameters to a parameter file when given its filename.

*** XML configs

#+BEGIN_SRC xml :tangle samples/config/sheep.xml
  <?xml version="1.0"?>
  <data>
    <source>
      <file>source_file_a.c</file>
      <dir>some_sub_dir</dir>
    </source>
    <scripts>
      <start>start.sh</start>
      <restart>restart.sh</restart>
      <make>make.sh</make>
    </scripts>
  </data>
#+END_SRC

#+BEGIN_SRC ipython :session xmltest :exports both :results raw drawer
  import xml.etree.ElementTree as ET
  tree = ET.parse('samples/config/sheep.xml')
  root = tree.getroot()
  for child in root.find('./source'):
      print("{} : {}".format(child.tag, child.text))
  print([c.text for c in root.find('./source')])
#+END_SRC

#+RESULTS:
:RESULTS:
# Out[23]:
:END:

** Code

*** Imports

Import libraries

#+BEGIN_SRC ipython :session sheep :results none :tangle sheep/sheep.py
import os
import tempfile
import shutil
import uuid
import tarfile
import xml.etree.ElementTree as ET
import paramset
import parser
#+END_SRC

*** Utility functions

**** Expandings paths

Define a function to expand pathes with user variables and the ~ shorthand.

#+BEGIN_SRC ipython :session sheep :results none :tangle sheep/sheep.py
  def expand_path(path):
      path = os.path.expanduser(path)
      path = os.path.expandvars(path)
      return path

  def abs_expand_path(path, base=os.getcwd()):
      path = expand_path(path)
      if path != os.path.abspath(path):
          path = os.path.join(base, path)
      return path

#+END_SRC

**** Parse textfiles to lines

Define a function to parse a textfile and remove empty lines and text after #.

#+BEGIN_SRC ipython :session sheep :exports both :results none :tangle sheep/sheep.py
  def parse_file_to_lines( filepath ):
      """ Parse a textfile into a list with lines.
      Remove all text following the cahracter #.
      Discard empty lines."""
      lines = []

      with open(filepath, 'r') as f:
          for line in f:
              # Split the line and remove part after the first #
              line = line.strip().split('#')[0].strip()
              if line == "":
                  continue
              lines.append(line)
      return lines
#+END_SRC

**** Copy function for files and directories

Define a copy function that copies both, files and directories.

#+BEGIN_SRC ipython :session sheep :exports both :results none :tangle sheep/sheep.py
  def copy(src, dst):
      """ Copy both files and directories from src to dst.
      For files, copy2() and for directories copytree is used. """
      try:
          shutil.copy2(src, dst)
      except IsADirectoryError:
          try:
              shutil.copytree(src, dst)
          except FileExistsError:
              shutil.copytree(src, os.path.join(dst, os.path.basename(src)))
#+END_SRC

*** =Sheep= class

#+BEGIN_SRC ipython :session sheep :exports both :results raw drawer :tangle sheep/sheep.py
  class Sheep:

      def __init__(self, setup_dir, config_file='sheep.xml'):
          self.uuid = str(uuid.uuid4())
          self.temp_dir = None
          self.temp_dir_obj = None
          self.src_list = []
          self.scripts = {}
          self.param_set = None
          self.parameters = {}
          self.parameters_in_config = {}
          self.tar_file = None
          self.setup_dir = os.path.abspath(setup_dir)
          # If the config dir is not an absolute path assume its meant to be inside the setup dir.
          if config_file != os.path.abspath(config_file):
              config_file = os.path.join( setup_dir, config_file )
          self.cfg = ET.parse(config_file);
          self.add_uuid()
          self.parse_src_list()
          #self.parse_parameter_config()
          self.provide_temp_dir()
          self.copy_src()
          self.copy_scripts()
          self.save_config()
          self.save_uuid()
          self.construct_param_set()

      def add_uuid(self):
          """ Insert the uuid into config. """
          elem = ET.Element('uuid')
          elem.text = self.uuid
          self.cfg.getroot().insert(0, elem)

      def save_uuid(self):
          """ Save the uuid to a file. """
          with open( os.path.join( self.temp_dir, "uuid"), "w" ) as of:
              of.write(self.uuid)

      def provide_temp_dir(self):
          """ Create a save temporary directory, unique for every instance of sheep. """
          if self.temp_dir is None:
              self.temp_dir_obj = tempfile.TemporaryDirectory(prefix = self.uuid)
              self.temp_dir = self.temp_dir_obj.name

      def parse_src_list(self):
          """ Provide a list of paths to be copied to the temp directory
          directory. User variables and the ~ shorthand are expanded. """
          self.src_list = [c.text for c in self.cfg.find('./source')]

      def save_config(self):
          """ Copy the config file as reference. """
          dst = os.path.join(self.temp_dir, "sheep.xml" )
          self.cfg.write( dst, encoding='UTF-8', xml_declaration=True )

      def copy_scripts(self):
          """ Provide a list of paths of scripts. They need to be copied aswell.
          User variables and the ~ shorthand are expanded. """
          scripts = self.cfg.find('./scripts')
          for script in scripts:
              path = script.text
              self.scripts[script.tag] = path
              copy( abs_expand_path(path, base = self.setup_dir),
              os.path.join(self.temp_dir, "{}_sheep".format(script.tag) ) )

      def parse_parameter_config(self, parameters_file):
          """ Load the names of the parameters, how to translate them from generic names
          and the desitination file from the parameters.txt file. """
          lines = parse_file_to_lines( parameters_file )
          for line in lines:
              parts = line.split()
              if parts[1] == '-':
                  parts[1] = parts[0]
              self.parameters[parts[0]] = parts[1:]

      def get_temp_path(self, filename ):
          """ Return the absolute path of the file *filename* inside the temp dir. """
          return os.path.join( self.temp_dir, filename)

      def list_temp_dir(self):
          """ Return a list with absolute paths of every file or directory in
          the temp folder. """
          return [os.path.join(self.temp_dir, f) for f in os.listdir(self.temp_dir)]

      def copy_src(self):
          if len(self.src_list) == 0:
              print("Warning: Nothing is copyied b.c. src_list is empty.")
          for path in self.src_list:
              try:
                  copy(abs_expand_path(path, base = self.setup_dir), self.temp_dir)
              except TypeError:
                  print("Error while trying to copy {}".format(path));


      def make_tar(self):
          """ Make a gzipped tar file containing all files and directories
          inside the tmp folder. """
          self.save_changes()
          self.tar_file = self.get_temp_path( 'content.tgz' )
          files = self.list_temp_dir()
          with tarfile.open( self.tar_file , 'x:gz') as tf:
              for path in files:
                  tf.add(path, arcname = path.replace(self.temp_dir,'').lstrip('/'))

      def save_tar(self, dst):
          """ Construct and move the tar file to the given location. """
          if self.tar_file is None:
              self.make_tar()
          shutil.move(self.tar_file, dst)

      def enforce_param_known(self, name):
          if not (name in self.parameters or name in self.parameters_in_config):
              raise ValueError("Setting the parameter {} is not allowed. Make sure it is spelled correct and that its either definde in the config or already present inside a config file.".format(name))

      def construct_param_set(self):
          """ Make a param set object using the parser type specified in the config """
          parserType = self.cfg.find('./paramset/type').text
          paramFile = self.cfg.find('./paramset/path').text
          paramFile = self.get_temp_path(paramFile)
          try:
              Parser = parser.avail[parserType]
              par = Parser(paramFile)
              self.param_set = paramset.ParamSet(par)
          except KeyError:
              print("Could not find parser type {}".format(parserType))

      def set_param(self, param, value ):
          try:
              self.param_set.set_param(param, value)
          except KeyError:
              print("Could not find parameter {}".format(param))
              raise

      def save_changes(self):
          """ Write saves to disk """
          if not self.param_set is None:
              self.param_set.parser.save()

      def translate_param_name(self, to_convention, name ):
          pass


#+END_SRC

#+RESULTS:
:RESULTS:
# Out[5]:
:END:

** Tests

*** temp dir creation

#+BEGIN_SRC ipython :session sheep :results output drawer
  s = Sheep()
  s.provide_temp_dir()
  s.temp_dir
  with open(os.path.join(s.temp_dir, "test.txt"), 'w') as of:
      of.write("foo")
  with open(os.path.join(s.temp_dir, "test.txt"), 'r') as fi:
      print(fi.read())
#+END_SRC

#+RESULTS:
:RESULTS:
foo
:END:

*** text file to line list parser

#+BEGIN_SRC ipython :session sheep :exports both :results output drawer
  tmpdir = tempfile.TemporaryDirectory()
  tmp = tmpdir.name
  tmpfile = os.path.join(tmp, 'test.txt')
  with open(tmpfile, 'w') as tf:
      tf.write('# First comment line\n')
      tf.write('some important data\n')
      tf.write('data with # comment\n')
  print(parse_file_to_lines(tmpfile))
  tmpdir.cleanup()
#+END_SRC

#+RESULTS:
:RESULTS:
['some important data', 'data with']
:END:

*** copy function

#+BEGIN_SRC ipython :session sheep :exports both :results output drawer
    # Create a temp folder to work in
  with tempfile.TemporaryDirectory(prefix = str(uuid.uuid4())) as tmp:

      # Create a file and a folder to copy.
      testdir = os.path.join(tmp, 'from/testdir')
      os.makedirs( testdir )
      tmpfile = os.path.join(tmp, 'from/test.txt')
      with open(tmpfile, 'w') as tf:
          tf.write('some file')

      # Make a folder to copy to and try to copy
      todir = os.path.join(tmp, 'to')
      os.makedirs( todir )
      copy( tmpfile, todir )
      copy( testdir, todir )

      print(os.listdir( todir ))
#+END_SRC

#+RESULTS:
:RESULTS:
['testdir', 'test.txt']
:END:

*** get a uuid

#+BEGIN_SRC ipython :session :exports both :results output drawer
import uuid
print(str(uuid.uuid4()))
#+END_SRC

#+RESULTS:
:RESULTS:
0256843e-4b64-459e-b021-f97868677813
:END:
*** copy src folder and make a tar

#+BEGIN_SRC ipython :session sheep :exports both :results output drawer
s = Sheep()
src_dir = '/home/thomas/repo/fargo3d'
s.src_list = [os.path.join(src_dir, f) for f in os.listdir('/home/thomas/repo/fargo3d')]
s.copy_src()
print(os.listdir( s.temp_dir ))
print(s.list_temp_dir())
#+END_SRC

#+RESULTS:
:RESULTS:
['planets', 'test_suite', 'Makefile', 'outputs', 'README', 'version.txt', 'matplotlibrc', 'in', 'license.txt', 'scripts', 'src', 'setups', 'utils', 'std']
['/tmp/65acb71f-fae8-4476-8a1d-380738d8f6b14vltgy88/planets', '/tmp/65acb71f-fae8-4476-8a1d-380738d8f6b14vltgy88/test_suite', '/tmp/65acb71f-fae8-4476-8a1d-380738d8f6b14vltgy88/Makefile', '/tmp/65acb71f-fae8-4476-8a1d-380738d8f6b14vltgy88/outputs', '/tmp/65acb71f-fae8-4476-8a1d-380738d8f6b14vltgy88/README', '/tmp/65acb71f-fae8-4476-8a1d-380738d8f6b14vltgy88/version.txt', '/tmp/65acb71f-fae8-4476-8a1d-380738d8f6b14vltgy88/matplotlibrc', '/tmp/65acb71f-fae8-4476-8a1d-380738d8f6b14vltgy88/in', '/tmp/65acb71f-fae8-4476-8a1d-380738d8f6b14vltgy88/license.txt', '/tmp/65acb71f-fae8-4476-8a1d-380738d8f6b14vltgy88/scripts', '/tmp/65acb71f-fae8-4476-8a1d-380738d8f6b14vltgy88/src', '/tmp/65acb71f-fae8-4476-8a1d-380738d8f6b14vltgy88/setups', '/tmp/65acb71f-fae8-4476-8a1d-380738d8f6b14vltgy88/utils', '/tmp/65acb71f-fae8-4476-8a1d-380738d8f6b14vltgy88/std']
:END:

#+BEGIN_SRC ipython :session sheep :exports both :results raw drawer
s.make_tar()
#+END_SRC

#+RESULTS:
:RESULTS:
# Out[127]:
:END:

Inspect the tar file

#+BEGIN_SRC ipython :session sheep :exports both :results raw drawer
  with tarfile.open( s.tar_file, 'r:gz') as tf:
      print(tf.getnames())
#+END_SRC

#+RESULTS:
:RESULTS:
# Out[116]:
:END:

Now move the tar file to another folder for testing the =move_tar_to= function.

#+BEGIN_SRC ipython :session sheep :exports both :results raw drawer
move_to_dir = os.path.join(s.temp_dir, 'move_to')
os.makedirs( move_to_dir)
s.move_tar_to( os.path.join( move_to_dir, "sheeps_tmp_content.tgz"))
os.listdir( move_to_dir)
#+END_SRC

#+RESULTS:
:RESULTS:
# Out[128]:
: ['sheeps_tmp_content.tgz']
:END:
*** test the config file parsers

#+BEGIN_SRC ipython :session sheep :exports both :results output drawer
s = Sheep('sampleconfig')
print(s.parameters)
print(s.src_list)
#+END_SRC

#+RESULTS:
:RESULTS:
{'DiskMass': ['Mdisk', '0.1'], 'Rstar': ['Rstar', '1.e-5']}
['readme.org']
:END:
*** Trigger errors for missing config files

There should be some sample config files.

#+BEGIN_SRC ipython :session :exports both :results output drawer
!ls samples/config
#+END_SRC

#+RESULTS:
:RESULTS:
parameters.txt	sources.txt
:END:

**** Missing config

#+BEGIN_SRC ipython :session sheep :exports both :results output drawer
  try:
      s = Sheep('samples')
  except Exception as e:
      print(e)
#+END_SRC

#+RESULTS:
:RESULTS:
[Errno 2] No such file or directory: 'sheep/sources.txt'
:END:

**** Missing mandatory script file

#+BEGIN_SRC ipython :session sheep :exports both :results output drawer
  s = Sheep('samples', 'config')
  try:
      s.enforce_scripts_available()
  except FileNotFoundError as e:
      print("Cached error: {}".format(e))
#+END_SRC

#+RESULTS:
:RESULTS:
Cached error: Could not find start.py which is a mandatory script when using sheep!
:END:

**** Param not known

#+BEGIN_SRC ipython :session sheep :exports both :results output drawer
  s = Sheep('samples', 'config')
  try:
      s.enforce_param_known( 'foo' )
  except ValueError as e:
      print("Cached error: {}".format(e))
#+END_SRC

#+RESULTS:
:RESULTS:
Cached error: Setting the parameter foo is not allowed. Make sure it is spelled correct and that its either definde in the config or already present inside a config file.
:END:

* ParamSet

** Description

To manage the interaction with different parameter files it is useful to
have an abstract interface.
This is the purpose of =ParamSet=.

** Features

1. provide a common =set_param()= function
2. act as a meta parameter set which holds different param sets for every config file
3. using the sheep config, decide into which param set/config file a parameter is written

** Implementation

*** purely abstracted from files and syntax

Do not bother with file access and ini file syntax or structure.
Implement special parsers for every type of parameter file.

*** minimize interaction with parsers

Only interact with parser by requesting the parameter dict.
A parser to be used with =ParamSet= should have a =get_param_dict()= function
which returns a hirarchical presentation of the parameters in form of a =Dict=.
Changes to the parameters should be made in this dict.

*** structure of parameter dicts

The structure of the parameter dicts is as follows.

+ key-value pairs are stored directly in the dict
+ values are always stored in a list, which might have multiple entries
+ if the parameters are grouped, add a group by using its name as the key
  and a dict of the group key-value pairs as value (do not use a list in this case)

** Code

*** imports

#+BEGIN_SRC ipython :session sheep :exports both :results raw drawer :tangle sheep/paramset.py
import os
from collections import OrderedDict as ODict
#+END_SRC

*** parameter lookup table

There could be the case that two parameters in different blocks have the same name.
For the situation here, astrophysical simulations, this is probably a bad idea
anyways, but better be safe than sorry.

Build a dict of parameters containing the group of the parameter.
Put the group in a list and simply append a possible additional group names.
This makes it easy to handle collisions and at the same time makes finding the
parameters easy.

#+BEGIN_SRC ipython :session sheep :exports both :results none :tangle sheep/paramset.py

  def parameter_lookup_dict(dct):
      """ Make a dict to lookup where a given parameter is stored. """
      lt = ODict()
      for group in dct:
          for key in dct[group]:
              if key in lt:
                  lt[key].append(group)
              else:
                  lt[key] = [group]
      # Finally add the key itself at the end
      for key in lt:
          lt[key].append(key)
      return lt
#+END_SRC

*** helpers to work on nested dicts

Use strategy from this [[https://stackoverflow.com/questions/14692690/access-nested-dictionary-items-via-a-list-of-keys][stackoverflow thread]] to handle accessing nested dicts
with lists of keys.

#+BEGIN_SRC ipython :session sheep :exports both :results none :tangle sheep/paramset.py
from functools import reduce
import operator

def getFromDict(dataDict, mapList):
    return reduce(operator.getitem, mapList, dataDict)

def setInDict(dataDict, mapList, value):
    getFromDict(dataDict, mapList[:-1])[mapList[-1]] = value
#+END_SRC

*** the class

#+BEGIN_SRC ipython :session sheep :exports both :results none :tangle sheep/paramset.py
  class ParamSet:

      def __init__(self, parser = None):
          if parser is None:
              raise RuntimeError("Need to initialize with a parameter file parser!")
          self.parser = parser
          self.dct = parser.get_param_dict()
          self.make_parameter_lookup_dict()

      def make_parameter_lookup_dict(self):
          """ Construct a dict to map names of parameters to a list of
          keys to find them in the dict """
          self.parameter_lookup_dict = parameter_lookup_dict(self.dct)

      def set_param(self, param, value):
          """ Set the parameter param to its new value. """
          # Parsers hold values inside of lists to handle
          # multiple values per param.
          if isinstance(value, str):
              value = [value]
          # make a string out of anything else if it doesn't have a length
          try:
              len(value)
          except TypeError:
              value = ["{}".format(value)]
          keyList = self.parameter_lookup_dict[param]
          setInDict(self.dct, keyList, value)

      def get_param(self, param):
          """ Get the parameter param. """
          keyList = self.parameter_lookup_dict[param]
          value = getFromDict(self.dct, keyList)
          # Parsers hold values inside of lists to handle
          # multiple values per param.
          if len(value) == 1:
              return value[0]
          else:
              return value


#+END_SRC


** Test the code

*** get a dict from a parser

#+BEGIN_SRC ipython :session sheep :exports both :results output
  import parser
  import pprint
  par = parser.IniParser('samples/plutoSetup/pluto.ini')
  pset = ParamSet(par)
  pprint.pprint(pset.parameter_lookup_dict)
#+END_SRC

#+RESULTS:
#+begin_example
OrderedDict([('X1-grid', ['Grid', 'X1-grid']),
             ('X2-grid', ['Grid', 'X2-grid']),
             ('X3-grid', ['Grid', 'X3-grid']),
             ('Levels', ['Chombo Refinement', 'Levels']),
             ('Ref_ratio', ['Chombo Refinement', 'Ref_ratio']),
             ('Regrid_interval', ['Chombo Refinement', 'Regrid_interval']),
             ('Refine_thresh', ['Chombo Refinement', 'Refine_thresh']),
             ('Tag_buffer_size', ['Chombo Refinement', 'Tag_buffer_size']),
             ('Block_factor', ['Chombo Refinement', 'Block_factor']),
             ('Max_grid_size', ['Chombo Refinement', 'Max_grid_size']),
             ('Fill_ratio', ['Chombo Refinement', 'Fill_ratio']),
             ('CFL', ['Time', 'CFL']),
             ('CFL_max_var', ['Time', 'CFL_max_var']),
             ('tstop', ['Time', 'tstop']),
             ('first_dt', ['Time', 'first_dt']),
             ('Solver', ['Solver', 'Solver']),
             ('X1-beg', ['Boundary', 'X1-beg']),
             ('X1-end', ['Boundary', 'X1-end']),
             ('X2-beg', ['Boundary', 'X2-beg']),
             ('X2-end', ['Boundary', 'X2-end']),
             ('X3-beg', ['Boundary', 'X3-beg']),
             ('X3-end', ['Boundary', 'X3-end']),
             ('uservar', ['Static Grid Output', 'uservar']),
             ('output_dir', ['Static Grid Output', 'output_dir']),
             ('dbl', ['Static Grid Output', 'dbl']),
             ('flt', ['Static Grid Output', 'flt']),
             ('vtk', ['Static Grid Output', 'vtk']),
             ('tab', ['Static Grid Output', 'tab']),
             ('ppm', ['Static Grid Output', 'ppm']),
             ('png', ['Static Grid Output', 'png']),
             ('log', ['Static Grid Output', 'log']),
             ('analysis', ['Static Grid Output', 'analysis']),
             ('Checkpoint_interval',
              ['Chombo HDF5 output', 'Checkpoint_interval']),
             ('Plot_interval', ['Chombo HDF5 output', 'Plot_interval']),
             ('SigmaRef', ['Parameters', 'SigmaRef']),
             ('Mplanet', ['Parameters', 'Mplanet']),
             ('Pericenter', ['Parameters', 'Pericenter']),
             ('AspectRatio', ['Parameters', 'AspectRatio']),
             ('ViscosityAlpha', ['Parameters', 'ViscosityAlpha']),
             ('Inclination', ['Parameters', 'Inclination']),
             ('Rplanet', ['Parameters', 'Rplanet']),
             ('Smoothing', ['Parameters', 'Smoothing']),
             ('ForceCutoff', ['Parameters', 'ForceCutoff']),
             ('DensityFloor', ['Parameters', 'DensityFloor']),
             ('WDThetaBegRel', ['Parameters', 'WDThetaBegRel']),
             ('WDRIn', ['Parameters', 'WDRIn']),
             ('WDROut', ['Parameters', 'WDROut'])])
#+end_example

*** change a param in a parser

#+BEGIN_SRC ipython :session sheep :exports both :results output
  import parser
  import pprint
  par = parser.IniParser('samples/plutoSetup/pluto.ini')
  pset = ParamSet(par)
  pset.set_param('tstop', '40.0')
  print(pset.get_param('tstop'))
#+END_SRC

#+RESULTS:
: 40.0


*** write a changed param back to file

#+BEGIN_SRC ipython :session sheep :exports both :results output
  import parser
  import pprint
  par = parser.IniParser('samples/plutoSetup/pluto.ini')
  pset = ParamSet(par)
  pset.set_param('tstop', '40.0')
  par.save('samples/plutoSetup/pluto_testwrite.ini')
  par2 = parser.IniParser('samples/plutoSetup/pluto_testwrite.ini')
  print(par2.get_param_dict()['Time']['tstop'])
#+END_SRC

#+RESULTS:
: ['40.0']

* Parsers

This section contains the parsers for different parameter files.

** ini file parser for PLUTO

*** Introduction

This document is a development file for an implemenation of a parser for
runtime config files of the PLUTO astrophysics code.

*** Features

**** DONE ini file to memory

+ load the ini file and parse it into an ordered dictionary
+ the root dict contains all dicts of groups
+ the dicts for groups are also ordered and have lists to store the values

**** DONE Save the config dict to file

+ parse the config dict into lines using some rule to format the white spaces
  (why not make the file pretty if we parse it anyways)
+ save the generated lines to a file, possibly the same as the source file

**** TODO Replace parameters

+ replace the values of parameters at arbitrary positions.
+ support only naming the parameter without the group
+ raise exceptions upon name collision
+ support specifying the group as optional parameter

*** Syntax

The syntax is probably identical to the one of Microsoft ini files.
There is support for different groups, which are indicated by =[]=.
Key value pairs are white-space separated and there might be multiple values.

An example ilustrated the syntax. It is taken from a 3D PLUTO setup and
configures the grid and some parameters.

#+BEGIN_EXAMPLE
[Grid]

X1-grid    1    0.4   256   u    2.5
X2-grid    1   -0.3   72    u    0.3
X3-grid    1    0.0   512   u    6.283185307

...

[Parameters]

Mplanet          6.e-5
AspectRatio      0.1
ViscosityAlpha   0.004
#+END_EXAMPLE

*** Sample config

A sample config is available at =samples/plutoSetup/pluto.ini=.

*** Parser Code

**** Imports

Import libraries

#+BEGIN_SRC ipython :session plpar :exports both :results none :tangle sheep/parser.py
import os
from collections import OrderedDict as ODict
#+END_SRC

**** Loading the ini file

Load the file into lines

#+BEGIN_SRC ipython :session plpar :exports both :results none
  lines = []
  with open('samples/plutoSetup/pluto.ini', 'r') as cf:
      for line in cf:
          lines.append(line.strip())
#+END_SRC

inspect the lines in a different buffer.

#+BEGIN_SRC ipython :session plpar :exports both :results none
print(lines)
#+END_SRC

The output looks as expected and shows that there are also some tabs as white space characters.

**** Parse groups to lists

Now go through the lines and extract groups.
Write all lines after a line which indicates a group to a separate list.
These are lines having a =[= as their first character.
Also make sure that the last character is a =]= and raise an exception if its missing.

#+BEGIN_SRC ipython :session plpar :exports both :results raw drawer
  def parse_to_grouped_lines(lines):
      # Initialize a first group to store key value pairs listed before the first group.
      grouped_lines = [[]]
      for line in lines:
          # Skip empty lines
          if line == "":
              continue
          # Identiy a header line
          if line[0] == '[':
              if line[-1] != ']':
                  raise ValueError('Found a line starting wih "[" but not ending in "]"!')
              grouped_lines.append([line])
          # Append normal lines to the last group
          else:
              grouped_lines[-1].append(line)
      return grouped_lines
#+END_SRC

#+RESULTS:
:RESULTS:
# Out[3]:
:END:

Print the lines
#+BEGIN_SRC ipython :session plpar :exports both :results output
  for group in parse_to_grouped_lines(lines):
      print(group)
#+END_SRC

#+RESULTS:
: []
: ['[Grid]', 'X1-grid    1    0.4            256    u    2.5', 'X2-grid   1   1.0471975511965976   72   u   2.0943951023931953', 'X3-grid    1    0.0            512    u    6.283185307']
: ['[Chombo Refinement]', 'Levels           4', 'Ref_ratio        2 2 2 2 2', 'Regrid_interval  2 2 2 2', 'Refine_thresh    0.3', 'Tag_buffer_size  3', 'Block_factor     8', 'Max_grid_size    64', 'Fill_ratio       0.75']
: ['[Time]', 'CFL              0.33', 'CFL_max_var      1.1', 'tstop            20.0', 'first_dt         1.e-4']
: ['[Solver]', 'Solver         hllc']
: ['[Boundary]', 'X1-beg\t      reflective', 'X1-end        reflective', 'X2-beg        reflective', 'X2-end        reflective', 'X3-beg        periodic', 'X3-end        periodic']
: ['[Static Grid Output]', 'uservar    0', 'output_dir ./out/sim', 'dbl       1.0  -200   single_file', 'flt       -1.0  -1   single_file', 'vtk       -1.0 -1   single_file', 'tab       -1.0  -1', 'ppm       -1.0  -1', 'png       -1.0  -1', 'log        5', 'analysis  0.001']
: ['[Chombo HDF5 output]', 'Checkpoint_interval  -1.0  0', 'Plot_interval         1.0  0']
: ['[Parameters]', 'SigmaRef\t\t\t0.000645246309031885', 'Mplanet\t\t\t\t6.e-5', 'Pericenter          -1.5707963268', 'AspectRatio\t\t\t0.1', 'ViscosityAlpha\t\t0.004', 'Inclination\t\t\t50.0', 'Rplanet\t\t\t\t5.2', 'Smoothing\t\t\t0.5', 'ForceCutoff\t\t\t0.8', 'DensityFloor\t\t1.e-20', 'WDThetaBegRel\t\t0.8', 'WDRIn\t\t\t\t0.4', 'WDROut\t\t\t\t2.1']

**** Parse groups to dicts

Now parse the lines into ordered dicts.
Split the lines with and store the first part as key and the rest as values.



#+BEGIN_SRC ipython :session plpar :exports both :results none :tangle sheep/parser.py
  def parse_to_dict(lines):
      # Initialize a first group to store key value pairs listed before the first group.
      groups = ODict()
      stats = ODict()
      name = '_root'
      groups[name] = ODict()
      stats[name] = [0,0]
      num_comment = 1
      for line in lines:
          line = line.strip()
          # Skip empty lines
          if line == "":
              continue
          # Identify a header line
          if line[0] == '[':
              if line[-1] != ']':
                  raise ValueError('Found a line starting wih "[" but not ending in "]"!')
              name = line.lstrip('[').rstrip(']')
              groups[name] = ODict()
              stats[name] = [0, 0]
          # Append normal lines to the last group
          else:
              if line[0] in ["#",";"]:
                  groups[name]["__comment_" + "{}".format(num_comment)] = line
                  num_comment += 1
              else:
                  parts = line.split()
                  groups[name][parts[0]] = parts[1:]
                  stats[name] += [0]*(len(parts) - len(stats[name]))
                  for n,p in enumerate(parts):
                      stats[name][n] = max(stats[name][n], len(p))


      return (groups, stats)
#+END_SRC

Parse the lines to a dict.

#+BEGIN_SRC ipython :session plpar :exports both :results output
import pprint
cfg_dict, stats = parse_to_dict(lines)
pprint.pprint(cfg_dict)
#+END_SRC

#+RESULTS:
#+begin_example
OrderedDict([('_root', []),
             ('Grid',
              OrderedDict([('X1-grid', ['1', '0.4', '256', 'u', '2.5']),
                           ('X2-grid',
                            ['1',
                             '1.0471975511965976',
                             '72',
                             'u',
                             '2.0943951023931953']),
                           ('X3-grid',
                            ['1', '0.0', '512', 'u', '6.283185307'])])),
             ('Chombo Refinement',
              OrderedDict([('Levels', ['4']),
                           ('Ref_ratio', ['2', '2', '2', '2', '2']),
                           ('Regrid_interval', ['2', '2', '2', '2']),
                           ('Refine_thresh', ['0.3']),
                           ('Tag_buffer_size', ['3']),
                           ('Block_factor', ['8']),
                           ('Max_grid_size', ['64']),
                           ('Fill_ratio', ['0.75'])])),
             ('Time',
              OrderedDict([('CFL', ['0.33']),
                           ('CFL_max_var', ['1.1']),
                           ('tstop', ['20.0']),
                           ('first_dt', ['1.e-4'])])),
             ('Solver', OrderedDict([('Solver', ['hllc'])])),
             ('Boundary',
              OrderedDict([('X1-beg', ['reflective']),
                           ('X1-end', ['reflective']),
                           ('X2-beg', ['reflective']),
                           ('X2-end', ['reflective']),
                           ('X3-beg', ['periodic']),
                           ('X3-end', ['periodic'])])),
             ('Static Grid Output',
              OrderedDict([('uservar', ['0']),
                           ('output_dir', ['./out/sim']),
                           ('dbl', ['1.0', '-200', 'single_file']),
                           ('flt', ['-1.0', '-1', 'single_file']),
                           ('vtk', ['-1.0', '-1', 'single_file']),
                           ('tab', ['-1.0', '-1']),
                           ('ppm', ['-1.0', '-1']),
                           ('png', ['-1.0', '-1']),
                           ('log', ['5']),
                           ('analysis', ['0.001'])])),
             ('Chombo HDF5 output',
              OrderedDict([('Checkpoint_interval', ['-1.0', '0']),
                           ('Plot_interval', ['1.0', '0'])])),
             ('Parameters',
              OrderedDict([('SigmaRef', ['0.000645246309031885']),
                           ('Mplanet', ['6.e-5']),
                           ('Pericenter', ['-1.5707963268']),
                           ('AspectRatio', ['0.1']),
                           ('ViscosityAlpha', ['0.004']),
                           ('Inclination', ['50.0']),
                           ('Rplanet', ['5.2']),
                           ('Smoothing', ['0.5']),
                           ('ForceCutoff', ['0.8']),
                           ('DensityFloor', ['1.e-20']),
                           ('WDThetaBegRel', ['0.8']),
                           ('WDRIn', ['0.4']),
                           ('WDROut', ['2.1'])]))])
#+end_example

**** Write the dict back to strings

+ leave blank lines between header lines and the key value pair lines.
+ no blank line at the beginning

#+BEGIN_SRC ipython :session plpar :exports both :results none :tangle sheep/parser.py
  def parse_dict_to_str(dct, stats=None):
      lines = []
      for group in dct:
          # blank line before the group header
          if len(lines) > 0:
              lines.append('')
          # Write the header if group is not the root.
          if group != '_root':
              lines.append('[{}]'.format(group))
              lines.append('')
          # Write the key value pairs
          for key in dct[group]:
              if key[:9] == "__comment":
                  lines.append("")
                  lines.append(dct[group][key])
                  lines.append("")
              elif stats is None:
                  lines.append('{}   {}'.format( key, '   '.join(dct[group][key])  ))
              else:
                  st = stats[group]
                  line = format(key, '{}s'.format(st[0]))
                  for n, val in enumerate(dct[group][key]):
                      line += '   ' + format(val, '{}s'.format(st[n+1]))
                  lines.append(line)
      return lines
#+END_SRC

Test the output

#+BEGIN_SRC ipython :session plpar :exports both :results output
  for line in parse_dict_to_str(cfg_dict, stats):
      print(line)
#+END_SRC

#+RESULTS:
#+begin_example
[Grid]

X1-grid   1   0.4                  256   u   2.5
X2-grid   1   1.0471975511965976   72    u   2.0943951023931953
X3-grid   1   0.0                  512   u   6.283185307

[Chombo Refinement]

Levels            4
Ref_ratio         2      2   2   2   2
Regrid_interval   2      2   2   2
Refine_thresh     0.3
Tag_buffer_size   3
Block_factor      8
Max_grid_size     64
Fill_ratio        0.75

[Time]

CFL           0.33
CFL_max_var   1.1
tstop         20.0
first_dt      1.e-4

[Solver]

Solver   hllc

[Boundary]

X1-beg   reflective
X1-end   reflective
X2-beg   reflective
X2-end   reflective
X3-beg   periodic
X3-end   periodic

[Static Grid Output]

uservar      0
output_dir   ./out/sim
dbl          1.0         -200   single_file
flt          -1.0        -1     single_file
vtk          -1.0        -1     single_file
tab          -1.0        -1
ppm          -1.0        -1
png          -1.0        -1
log          5
analysis     0.001

[Chombo HDF5 output]

Checkpoint_interval   -1.0   0
Plot_interval         1.0    0

[Parameters]

SigmaRef         0.000645246309031885
Mplanet          6.e-5
Pericenter       -1.5707963268
AspectRatio      0.1
ViscosityAlpha   0.004
Inclination      50.0
Rplanet          5.2
Smoothing        0.5
ForceCutoff      0.8
DensityFloor     1.e-20
WDThetaBegRel    0.8
WDRIn            0.4
WDROut           2.1
#+end_example

Looks just as desired.

**** =IniParser= class

Define a parser class to bring everything together

#+BEGIN_SRC ipython :session plpar :exports both :results none :tangle sheep/parser.py
  class IniParser:

      def __init__(self, inifile):
          self.inifile = os.path.abspath(inifile)
          self.load()

      def load(self):
          """ Load the ini file into memory. """
          with open(self.inifile, 'r') as rf:
              self.cfg_dct, self.stats = parse_to_dict(rf)

      def parse_dict_to_str(self):
          """ Write the dict into lines. """
          return parse_dict_to_str(self.cfg_dct, self.stats)

      def save(self, path=None):
          """ Write the config back to the file by default or to any file specified by *path*. """
          if path is None:
              path = self.inifile
          with open(path, 'w') as of:
              of.write('\n'.join(self.parse_dict_to_str()))

      def get_param_dict(self):
          """ Return the parameter dict. """
          return self.cfg_dct
#+END_SRC

Now load the ini using the class and print it.
#+BEGIN_SRC ipython :session plpar :exports both :results none
  par = IniParser('samples/plutoSetup/pluto.ini')
  for l in par.parse_dict_to_str():
      print(l)
#  par.write_to_file('test.ini')
#+END_SRC


**** class dict

#+BEGIN_SRC ipython :exports both :results none :tangle sheep/parser.py
  # List parser classes available in this implementation.
  # This is handy for specifying a parser class in a config file.
  avail = {
      'plutoIni' : IniParser,
      'fargo3dIni' : IniParser
  }
#+END_SRC


** fargo3d par files

*** Intro

The =fargo3d= code, has config files very similar to standard
=.ini= files.
Though, comments are done with =#= instead =;=.

Just try using the pluto parse.

*** Load lines

#+BEGIN_SRC ipython :session plpar :exports both :results none
  lines = []
  with open('samples/fargo.par', 'r') as cf:
      for line in cf:
          lines.append(line.strip())
#+END_SRC

#+BEGIN_SRC ipython :session plpar :exports both :results output
  for line in lines:
      print(line)
#+END_SRC

#+RESULTS:
#+begin_example
### Run only this parameter file is FARGO3D was build using the setup 'fargo'
Setup			fargo

### Disk parameters

AspectRatio     	0.05            Thickness over Radius in the disc
Sigma0			6.3661977237e-4	Surface Density at r=1
Nu			0.0		Uniform kinematic viscosity
SigmaSlope		0.0		Slope of the surface density
FlaringIndex		0.0

### Planet parameters

PlanetConfig		planets/jupiter.cfg
ThicknessSmoothing 	0.6
RocheSmoothing 		0.0
Eccentricity		0.0
ExcludeHill		no
IndirectTerm		Yes


### Mesh parameters

Nx			384		Azimuthal number of zones
Ny               	128		Radial number of zones
Xmin			-3.14159265358979323844
Xmax			3.14159265358979323844
Ymin			0.4		Inner boundary radius
Ymax			2.5		Outer boundary radius
OmegaFrame     		1.0005
Frame			G

### Output control parameters

Ntot			1000		Total number of time steps
Ninterm	 		20		Time steps between outputs
DT			0.314159265359	Time step length. 2PI = 1 orbit
OutputDir		@outputs/fargo

#Plotting parameters

Log			yes

#+end_example


*** parse lines with pluto parser


#+BEGIN_SRC ipython :session plpar :exports both :results output
  groups, stats = parse_to_dict(lines)
  for g in groups:
      for key in groups[g]:
          print("{} : {}".format(key, groups[g][key]))
#+END_SRC

#+RESULTS:
#+begin_example
__comment_1 : ### Run only this parameter file is FARGO3D was build using the setup 'fargo'
Setup : ['fargo']
__comment_2 : ### Disk parameters
AspectRatio : ['0.05', 'Thickness', 'over', 'Radius', 'in', 'the', 'disc']
Sigma0 : ['6.3661977237e-4', 'Surface', 'Density', 'at', 'r=1']
Nu : ['0.0', 'Uniform', 'kinematic', 'viscosity']
SigmaSlope : ['0.0', 'Slope', 'of', 'the', 'surface', 'density']
FlaringIndex : ['0.0']
__comment_3 : ### Planet parameters
PlanetConfig : ['planets/jupiter.cfg']
ThicknessSmoothing : ['0.6']
RocheSmoothing : ['0.0']
Eccentricity : ['0.0']
ExcludeHill : ['no']
IndirectTerm : ['Yes']
__comment_4 : ### Mesh parameters
Nx : ['384', 'Azimuthal', 'number', 'of', 'zones']
Ny : ['128', 'Radial', 'number', 'of', 'zones']
Xmin : ['-3.14159265358979323844']
Xmax : ['3.14159265358979323844']
Ymin : ['0.4', 'Inner', 'boundary', 'radius']
Ymax : ['2.5', 'Outer', 'boundary', 'radius']
OmegaFrame : ['1.0005']
Frame : ['G']
__comment_5 : ### Output control parameters
Ntot : ['1000', 'Total', 'number', 'of', 'time', 'steps']
Ninterm : ['20', 'Time', 'steps', 'between', 'outputs']
DT : ['0.314159265359', 'Time', 'step', 'length.', '2PI', '=', '1', 'orbit']
OutputDir : ['@outputs/fargo']
__comment_6 : #Plotting parameters
Log : ['yes']
#+end_example



*** parse dict back to lines

#+BEGIN_SRC ipython :session plpar :exports both :results output
  groups, stats = parse_to_dict(lines)
  lines_from_groups = parse_dict_to_str(groups, stats)
  for line in lines_from_groups:
      print(line)
#+END_SRC

#+RESULTS:
#+begin_example

### Run only this parameter file is FARGO3D was build using the setup 'fargo'

Setup                fargo

### Disk parameters

AspectRatio          0.05                      Thickness   over        Radius      in        the       disc
Sigma0               6.3661977237e-4           Surface     Density     at          r=1
Nu                   0.0                       Uniform     kinematic   viscosity
SigmaSlope           0.0                       Slope       of          the         surface   density
FlaringIndex         0.0

### Planet parameters

PlanetConfig         planets/jupiter.cfg
ThicknessSmoothing   0.6
RocheSmoothing       0.0
Eccentricity         0.0
ExcludeHill          no
IndirectTerm         Yes

### Mesh parameters

Nx                   384                       Azimuthal   number      of          zones
Ny                   128                       Radial      number      of          zones
Xmin                 -3.14159265358979323844
Xmax                 3.14159265358979323844
Ymin                 0.4                       Inner       boundary    radius
Ymax                 2.5                       Outer       boundary    radius
OmegaFrame           1.0005
Frame                G

### Output control parameters

Ntot                 1000                      Total       number      of          time      steps
Ninterm              20                        Time        steps       between     outputs
DT                   0.314159265359            Time        step        length.     2PI       =         1      orbit
OutputDir            @outputs/fargo

#Plotting parameters

Log                  yes
#+end_example

* Applications

** Preparation

#+BEGIN_SRC ipython :session sheep :exports both :results none
  import importlib
  import sheep.parser
  import sheep.paramset
  import sheep
  import os
  import shutil
  importlib.reload(sheep)
  importlib.reload(sheep.parser)
  importlib.reload(sheep.paramset)
  os.path.expanduser('~/repo/sheep')
#+END_SRC

** Pluto

#+BEGIN_SRC ipython :session sheep :exports both :results none
  try:
      shutil.rmtree('test/pluto')
  except FileNotFoundError:
      pass
  os.makedirs('test/pluto')
  s = sheep.Sheep('samples/plutoSheepSetup')
  s.set_param("Inclination", 100.0)
  s.save_tar('test/pluto/content.tgz')
#+END_SRC

** fargo3d

#+BEGIN_SRC ipython :session sheep :exports both :results none
  try:
      shutil.rmtree('test/fargo3d')
  except FileNotFoundError:
      pass
  os.makedirs('test/fargo3d')
  setup_dir = os.path.expanduser('~/repo/fargo3d')
  config_file = os.path.expanduser('~/repo/fargo3d/sheep_pdi3d.xml')
  s = sheep.Sheep(setup_dir, config_file=config_file )
  s.set_param("AspectRatio", 0.2)
  s.save_tar('test/fargo3d/content.tgz')
#+END_SRC

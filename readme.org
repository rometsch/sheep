#+TITLE: =sheep= : a Simulation HElpEr for Parameters
#+AUTHOR: Thomas Rometsch
#+SETUPFILE: styles/theme-readtheorg-local.setup

* Introduction

Performing physics simulations requiries setting them up in the first place.
The physical setup needs to be defined, usually by writing some extra code for initial conditions.
At least this is the case for simulations of protoplanetary disks, the simulations I do, and for the codes PLUTO and FARGO3D.

In addition to the setup (the FARGO3D user guide explains the concept quite nicely), parameters have to be set.
Often, multiple runs of the same setup with different parameters are required.
One extreme of that are large parameter studies, in which the code should remain the same and only parameteres change.

Setting the parameters by hand in a text editor is fine for a small number of runs.
Having to deal with a large parameter space, however, this gets very tedious and time consuming.
Since the problem is well defined - changing a string in a text file - the process can be automated.

Using different codes with possibly different structure to simulate the same physical setup makes things even worse.
Let me illustrate this with an example.
I aim at running the same physical setup with two codes, the PLUTO and FARGO3D astrophysics hyrdordynamical codes.
The both allow the usage of setups and the both have files for specifying parameter.
In both cases there are two different parameter files
One for parameters which need to be known before compiling the code and one file for parameters which can be set after compilation.
Since I compile the code for every run anyways (the compilation time is neglegible compared to the simulation time), I don't want to bother with that.
I simply want to specify parameters using only one programmable interface for any type of paramerter (pre-compilation, post-compilation) and for any code.

This is where =sheep= comes in.

* Goals

1. abstract the process of setting parameters
   - when doing physics research, technical details should be irrelevant
   - hide different types of parameters (pre-/post-compilation) behind a common interface
2. define a generic interface for preparing physics simulations for different codes
   - streamline the preparation of simulations by providing a common interface
   - define common names for the parameters and translate them to each code
   - adapt to specific requirements of code in an automatic way
	 * choice of units
	 * syntax rules
3. provide scripts with a common interface
   - starting
	 * number of CPU cores
	 * number of GPU cores
	 * GPU device
   - restarting
	 * same as in starting
	 * output file to be used
   - making the code considering architechture choices
	 * parallel vs sequential (MPI)
	 * CPU vs GPU (CUDA)
4. support the usage of setups
5. check that parameters are reasonable by specifying simple rules (e.g. boundaries on the value)

* Implementation

Here is an outline of the steps =sheep= needs to be able to do.
Generic steps which are the same for avery code are marked by =(g)=.
Steps specific for each code are marked by =(s)=.

1. =(g)= Provide a temporary directory in which to prepare the simulation files.
2. =(s)= Copy all necessary files into the temp directory.
3. =(s)= Set the parameters using the common interface which launches a code specific parser.
4. =(s)= Provide the (re)start and make scripts
5. =(g)= Pack everything into a tar ball.

The programming language is =Python3=. This program probably doesn't support =Python2=!

All specific =(s)= parts need to be implemented for each new code by inheriting the abstract interface.

The changes to the parameter files are first done in memory.
After completing the process of setting the parameters, write the file from memory to the file.

Note that, as a design choice, parameters can only be set if they are
+ already in the config file
+ defined in the setup specific config
which is to avoid typo when setting the parameters automatically.

* Functions to be provided by =sheep=

** =set_param( name, value )= =(g)=

The function to set parameters should be of the form

+ =name= is the common name of the parameter which is translated to the parameter name in the code via a dictionary.
+ =value= is the value (or possibly multiple values in form of a list) of the parameter

Depending on the parameter, an appropriate code specific function is called.
Therefore, there must be an entry in the file =parameters.txt=

** =translate_param_name( to_convention, name )= =(g)=

Translate the parameter with =name= to the naming =to_convention=.

E.g. to translate from the generic parameter name =foo= to the code specific name of the code =BarCode= the call would be =translate_param_name( 'BarCode', 'foo')=.

To go the other way around and translate from the parameter with name 'FoO' from the code =BarCode= to the generic parameter name the call looks like =translate_param_name( 'generic', 'FoO')=.

The translation dictionaries need to be provided by the code specific implementation in a file called =parameters.txt=.

** =enforce_scripts_available()= =(g)=

This functions checks for the scripts
+ =start.py=
+ =restart.py=
+ =make.py=
which are supposed to be copied to the root of the temporary directory.
The function of these scripts is not checked, however.
Its the responsibility of the user to make them work properly.

** =provide_temp_dir()= =(g)=

This function provides a temporary directory.
The path is written into an object variable.

** =copy_src()= =(s)=

Copy the source files from a pre-defined directory to the temp directory for editing.
The source files/folders need to be specified in =sources.txt=.

** =load_param_file( filepath )= =(g), (s)=

Loads the parameter file at =filepath= into memory.
Automatically determine the syntax from the context.

** =save_param_file( filepath )= =(g), (s)=

Saves the parameter file from the memory to =filepath=.
Automatically determine the syntax from the context.

* Configuration

The configuration of =sheep= is accomplished using simple tab separated plain text files.
Comments in the configuration files can be done using the =#= character.
All text following a =#= character is ignored.

Every code specific sheep is supposed to have its own directory containing the configuration files.
This directory should ideally be inside the directory where the specific setup for the code is stored.

The directory structure of a setup could thus be

#+BEGIN_EXAMPLE
+ source_of_code
+ ini_file_for_code.txt
+ ...
+ sheep
  + sources.txt		# Files and folders to be copied from the parent dir
  + parameters.txt  # parameter names and locations
#+END_EXAMPLE

** The =parameters.txt= file.

This is the place where the parameters of a specific code are listed.
For every parameter, there must be a line defining the necessary information
+ generic name
+ code specific name
+ file to write the parameter to

The syntax is
#+BEGIN_EXAMPLE
generic_name	code_specific_name	param_file
#+END_EXAMPLE

If the code specific name is the same as the generic name, the second field should contain a minus =-=.

An exmaple:

#+BEGIN_EXAMPLE
DiskMass	-	code_params.txt		# same name
AspectRatio	h_asp	code_params.txt	# different names
#+END_EXAMPLE

Each implementation of the class =Sheep= must define how to read and write
parameters to a parameter file when given its filename.

* Code

Import libraries

#+BEGIN_SRC ipython :session sheep :results none :tangle sheep.py
import os
import tempfile
import shutil
import uuid
import tarfile
#+END_SRC

Define a function to expand pathes with user variables and the ~ shorthand.

#+BEGIN_SRC ipython :session sheep :results none :tangle sheep.py
  def expand_path(path):
      path = os.path.expanduser(path)
      path = os.path.expandvars(path)
      return path
#+END_SRC

Define a function to parse a textfile and remove empty lines and text after #.

#+BEGIN_SRC ipython :session sheep :exports both :results none :tangle sheep.py
  def parse_file_to_lines( filepath ):
      """ Parse a textfile into a list with lines.
      Remove all text following the cahracter #.
      Discard empty lines."""
      lines = []

      with open(filepath, 'r') as f:
          for line in f:
              # Split the line and remove part after the first #
              line = line.strip().split('#')[0].strip()
              if line == "":
                  continue
              lines.append(line)
      return lines
#+END_SRC

Define a copy function that copies both, files and directories.

#+BEGIN_SRC ipython :session sheep :exports both :results none :tangle sheep.py
  def copy(src, dst):
      """ Copy both files and directories from src to dst.
      For files, copy2() and for directories copytree is used. """
      try:
          shutil.copy2(src, dst)
      except IsADirectoryError:
          try:
              shutil.copytree(src, dst)
          except FileExistsError:
              shutil.copytree(src, os.path.join(dst, os.path.basename(src)))
#+END_SRC

#+BEGIN_SRC ipython :session sheep :exports both :results raw drawer :tangle sheep.py
  class Sheep:

      def __init__(self, setup_dir, config_dir='sheep'):
          self.uuid = str(uuid.uuid4())
          self.temp_dir = None
          self.temp_dir_obj = None
          self.src_list = []
          self.parameters = {}
          self.parameters_in_config = {}
          self.tar_file = None
          self.setup_dir = os.path.abspath(setup_dir)
          # If the config dir is not an absolute path assume its meant to be inside the setup dir.
          if config_dir != os.path.abspath(config_dir):
              config_dir = os.path.join( setup_dir, config_dir )
          try:
              sources_file = os.path.join(config_dir, 'sources.txt')
          except FileNotFoundError:
              print("Please give the right path for the setup and config dir and provide a sources.txt file!")
              raise
          try:
              parameters_file = os.path.join(config_dir, 'parameters.txt')
          except FileNotFoundError:
              print("Please give the right path for the setup and config dir and provide a parameters.txt file!")
              raise
          self.load_src_list( sources_file )
          self.load_parameter_config( parameters_file )

      def enforce_scripts_available(self):
          """ Check whether all required scripts are available inside the temp dir. """
          files = os.listdir(self.temp_dir)
          for s in ['start.py', 'restart.py', 'make.py']:
              if not s in files:
                  raise FileNotFoundError("Could not find {} which is a mandatory script when using sheep!".format(s))

      def provide_temp_dir(self):
          """ Create a save temporary directory, unique for every instance of sheep. """
          if self.temp_dir is None:
              self.temp_dir_obj = tempfile.TemporaryDirectory(prefix = self.uuid)
              self.temp_dir = self.temp_dir_obj.name

      def load_src_list(self, sources_file):
          """ Provide a list of paths to be copied to the temp directory
          directory. User variables and the ~ shorthand are expanded. """
          lines = parse_file_to_lines( sources_file )
          self.src_list = [expand_path(line) for line in lines]

      def load_parameter_config(self, parameters_file):
          """ Load the names of the parameters, how to translate them from generic names
          and the desitination file from the parameters.txt file. """
          lines = parse_file_to_lines( parameters_file )
          for line in lines:
              parts = line.split()
              if parts[1] == '-':
                  parts[1] = parts[0]
              self.parameters[parts[0]] = parts[1:]

      def get_temp_path(self, filename ):
          return os.path.join( self.temp_dir, filename)

      def list_temp_dir(self):
          """ Return a list with absolute paths of every file or directory in
          the temp folder. """
          return [os.path.join(self.temp_dir, f) for f in os.listdir(self.temp_dir)]

      def copy_src(self):
          if len(self.src_list) == 0:
              print("Warning: Nothing is copyied b.c. src_list is empty.")
          for path in self.src_list:
              copy(path, self.temp_dir)

      def make_tar(self):
          """ Make a gzipped tar file containing all files and directories
          inside the tmp folder. """
          self.tar_file = self.get_temp_path( 'content.tgz' )
          with tarfile.open( self.tar_file , 'x:gz') as tf:
              for path in self.list_temp_dir():
                  tf.add(path, arcname = path.lstrip(self.temp_dir))

      def move_tar_to(self, dst):
          """ Move the tar file to the given location. """
          shutil.move(self.tar_file, dst)

      def enforce_param_known(self, name):
          if not (name in self.parameters or name in self.parameters_in_config):
              raise ValueError("Setting the parameter {} is not allowed. Make sure it is spelled correct and that its either definde in the config or already present inside a config file.".format(name))

      def set_param( name, value ):
          pass

      def translate_param_name(self, to_convention, name ):
          pass


#+END_SRC

#+RESULTS:
:RESULTS:
# Out[172]:
:END:

* Tests

** temp dir creation

#+BEGIN_SRC ipython :session sheep :results output drawer
  s = Sheep()
  s.provide_temp_dir()
  s.temp_dir
  with open(os.path.join(s.temp_dir, "test.txt"), 'w') as of:
      of.write("foo")
  with open(os.path.join(s.temp_dir, "test.txt"), 'r') as fi:
      print(fi.read())
#+END_SRC

#+RESULTS:
:RESULTS:
foo
:END:

** text file to line list parser

#+BEGIN_SRC ipython :session sheep :exports both :results output drawer
  tmpdir = tempfile.TemporaryDirectory()
  tmp = tmpdir.name
  tmpfile = os.path.join(tmp, 'test.txt')
  with open(tmpfile, 'w') as tf:
      tf.write('# First comment line\n')
      tf.write('some important data\n')
      tf.write('data with # comment\n')
  print(parse_file_to_lines(tmpfile))
  tmpdir.cleanup()
#+END_SRC

#+RESULTS:
:RESULTS:
['some important data', 'data with']
:END:

** copy function

#+BEGIN_SRC ipython :session sheep :exports both :results output drawer
    # Create a temp folder to work in
  with tempfile.TemporaryDirectory(prefix = str(uuid.uuid4())) as tmp:

      # Create a file and a folder to copy.
      testdir = os.path.join(tmp, 'from/testdir')
      os.makedirs( testdir )
      tmpfile = os.path.join(tmp, 'from/test.txt')
      with open(tmpfile, 'w') as tf:
          tf.write('some file')

      # Make a folder to copy to and try to copy
      todir = os.path.join(tmp, 'to')
      os.makedirs( todir )
      copy( tmpfile, todir )
      copy( testdir, todir )

      print(os.listdir( todir ))
#+END_SRC

#+RESULTS:
:RESULTS:
['testdir', 'test.txt']
:END:

** get a uuid

#+BEGIN_SRC ipython :session :exports both :results output drawer
import uuid
print(str(uuid.uuid4()))
#+END_SRC

#+RESULTS:
:RESULTS:
0256843e-4b64-459e-b021-f97868677813
:END:
** copy src folder and make a tar

#+BEGIN_SRC ipython :session sheep :exports both :results output drawer
s = Sheep()
src_dir = '/home/thomas/repo/fargo3d'
s.src_list = [os.path.join(src_dir, f) for f in os.listdir('/home/thomas/repo/fargo3d')]
s.copy_src()
print(os.listdir( s.temp_dir ))
print(s.list_temp_dir())
#+END_SRC

#+RESULTS:
:RESULTS:
['planets', 'test_suite', 'Makefile', 'outputs', 'README', 'version.txt', 'matplotlibrc', 'in', 'license.txt', 'scripts', 'src', 'setups', 'utils', 'std']
['/tmp/65acb71f-fae8-4476-8a1d-380738d8f6b14vltgy88/planets', '/tmp/65acb71f-fae8-4476-8a1d-380738d8f6b14vltgy88/test_suite', '/tmp/65acb71f-fae8-4476-8a1d-380738d8f6b14vltgy88/Makefile', '/tmp/65acb71f-fae8-4476-8a1d-380738d8f6b14vltgy88/outputs', '/tmp/65acb71f-fae8-4476-8a1d-380738d8f6b14vltgy88/README', '/tmp/65acb71f-fae8-4476-8a1d-380738d8f6b14vltgy88/version.txt', '/tmp/65acb71f-fae8-4476-8a1d-380738d8f6b14vltgy88/matplotlibrc', '/tmp/65acb71f-fae8-4476-8a1d-380738d8f6b14vltgy88/in', '/tmp/65acb71f-fae8-4476-8a1d-380738d8f6b14vltgy88/license.txt', '/tmp/65acb71f-fae8-4476-8a1d-380738d8f6b14vltgy88/scripts', '/tmp/65acb71f-fae8-4476-8a1d-380738d8f6b14vltgy88/src', '/tmp/65acb71f-fae8-4476-8a1d-380738d8f6b14vltgy88/setups', '/tmp/65acb71f-fae8-4476-8a1d-380738d8f6b14vltgy88/utils', '/tmp/65acb71f-fae8-4476-8a1d-380738d8f6b14vltgy88/std']
:END:

#+BEGIN_SRC ipython :session sheep :exports both :results raw drawer
s.make_tar()
#+END_SRC

#+RESULTS:
:RESULTS:
# Out[127]:
:END:

Inspect the tar file

#+BEGIN_SRC ipython :session sheep :exports both :results raw drawer
  with tarfile.open( s.tar_file, 'r:gz') as tf:
      print(tf.getnames())
#+END_SRC

#+RESULTS:
:RESULTS:
# Out[116]:
:END:

Now move the tar file to another folder for testing the =move_tar_to= function.

#+BEGIN_SRC ipython :session sheep :exports both :results raw drawer
move_to_dir = os.path.join(s.temp_dir, 'move_to')
os.makedirs( move_to_dir)
s.move_tar_to( os.path.join( move_to_dir, "sheeps_tmp_content.tgz"))
os.listdir( move_to_dir)
#+END_SRC

#+RESULTS:
:RESULTS:
# Out[128]:
: ['sheeps_tmp_content.tgz']
:END:
** test the config file parsers

#+BEGIN_SRC ipython :session sheep :exports both :results output drawer
s = Sheep('sampleconfig')
print(s.parameters)
print(s.src_list)
#+END_SRC

#+RESULTS:
:RESULTS:
{'DiskMass': ['Mdisk', '0.1'], 'Rstar': ['Rstar', '1.e-5']}
['readme.org']
:END:
** Trigger errors for missing config files

There should be some sample config files.

#+BEGIN_SRC ipython :session :exports both :results output drawer
!ls samples/config
#+END_SRC

#+RESULTS:
:RESULTS:
parameters.txt	sources.txt
:END:

#+BEGIN_SRC ipython :session sheep :exports both :results output drawer
  try:
      s = Sheep('samples')
  except Exception as e:
      print(e)
#+END_SRC

#+RESULTS:
:RESULTS:
[Errno 2] No such file or directory: 'sheep/sources.txt'
:END:

#+BEGIN_SRC ipython :session sheep :exports both :results output drawer
  s = Sheep('samples', 'config')
  try:
      s.enforce_scripts_available()
  except FileNotFoundError as e:
      print("Cached error: {}".format(e))
#+END_SRC

#+RESULTS:
:RESULTS:
Cached error: Could not find start.py which is a mandatory script when using sheep!
:END:
